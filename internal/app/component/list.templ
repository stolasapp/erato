package component

import (
	"fmt"

	eratov1 "github.com/stolasapp/erato/internal/gen/stolasapp/erato/v1"
)

// ListType indicates what kind of items the list contains
type ListType string

const (
	ListTypeMixed      ListType = "mixed"      // Stories and Anthologies
	ListTypeChapters   ListType = "chapters"   // Chapters only
	ListTypeCategories ListType = "categories" // Categories only
)

// Filters represents the current filter state
type Filters struct {
	TypeFilter  string // "all", "story", "anthology"
	OnlyUnread  bool
	OnlyStarred bool
	ShowHidden  bool
}

// ListProps contains the configuration for a list
type ListProps struct {
	Title         string
	ListType      ListType
	Filters       FilterParams
	BaseURL       string // Base URL for filter HTMX requests
	NextPageToken string // Next page token from response (empty if no more pages)
}

// FilterBar renders the filter controls
templ FilterBar(props ListProps) {
	<nav class={ ClassFilters }>
		if props.ListType == ListTypeMixed {
			<div role="group" aria-label="Filter by type">
				@filterSegment(props, "all", "All", props.Filters.TypeFilter == "" || props.Filters.TypeFilter == "all")
				@filterSegment(props, "story", "Stories", props.Filters.TypeFilter == "story")
				@filterSegment(props, "anthology", "Anthologies", props.Filters.TypeFilter == "anthology")
			</div>
		}
		if props.ListType != ListTypeCategories {
			@filterToggle(props, "unread", "Unread", props.Filters.OnlyUnread)
		}
		if props.ListType == ListTypeMixed {
			@filterToggle(props, "starred", "Starred", props.Filters.OnlyStarred)
		}
		if props.ListType != ListTypeChapters {
			@filterToggle(props, "hidden", "Hidden", props.Filters.ShowHidden)
		}
	</nav>
}

templ filterSegment(props ListProps, typeVal, label string, active bool) {
	{{ url := props.Filters.WithType(typeVal).BuildURL(props.BaseURL) }}
	<button
		aria-pressed={ fmt.Sprintf("%t", active) }
		hx-get={ url }
		hx-push-url={ url }
		hx-target={ TargetListContainer }
		hx-swap="outerHTML"
	>
		{ label }
	</button>
}

templ filterToggle(props ListProps, filter, label string, active bool) {
	{{
		var url string
		switch filter {
		case "unread":
			url = props.Filters.WithUnread(!props.Filters.OnlyUnread).BuildURL(props.BaseURL)
		case "starred":
			url = props.Filters.WithStarred(!props.Filters.OnlyStarred).BuildURL(props.BaseURL)
		case "hidden":
			url = props.Filters.WithHidden(!props.Filters.ShowHidden).BuildURL(props.BaseURL)
		}
	}}
	<button
		aria-pressed={ fmt.Sprintf("%t", active) }
		hx-get={ url }
		hx-push-url={ url }
		hx-target={ TargetListContainer }
		hx-swap="outerHTML"
	>
		{ label }
		if active {
			<span aria-hidden="true">Ã—</span>
		}
	</button>
}

// EntryItem renders a single entry (story or anthology) in the list.
// The filters param is used to build the link with parent state via ForChild().
templ EntryItem(entry *eratov1.Entry, filters FilterParams) {
	{{ slug := EntrySlug(entry.GetPath()) }}
	{{ kind := entry.GetKind() }}
	<article
		id={ slug }
		data-kind={ kindToDataAttr(kind) }
		if entry.HasReadTime() {
			data-read
		}
		if entry.GetHidden() {
			data-hidden
		}
	>
		@Icon(kindToDataAttr(kind), 14)
		<a href={ templ.URL(filters.ForChild().BuildURL("/" + slug)) }>{ entry.GetDisplayName() }</a>
		@ResourceTimestamp(entry)
		<nav>
			if kind != eratov1.Entry_ANTHOLOGY {
				@ReadToggle(slug, entry.HasReadTime())
			}
			@ViewToggle(slug, entry.HasViewTime())
			@StarToggle(slug, entry.GetStarred())
			@HideToggle(slug, entry.GetHidden())
		</nav>
	</article>
}

// ChapterItem renders a single chapter in the list.
// The filters param is used to build the link with parent state via ForChild().
templ ChapterItem(chapter *eratov1.Chapter, filters FilterParams) {
	{{ slug := ChapterSlug(chapter.GetPath()) }}
	<article
		id={ slug }
		data-kind={ KindChapter }
		if chapter.HasReadTime() {
			data-read
		}
	>
		@Icon(KindChapter, 14)
		<a href={ templ.URL(filters.ForChild().BuildURL("/" + slug)) }>{ chapter.GetDisplayName() }</a>
		@ResourceTimestamp(chapter)
		<nav>
			@ReadToggle(slug, chapter.HasReadTime())
			@ViewToggle(slug, chapter.HasViewTime())
		</nav>
	</article>
}

// CategoryItem renders a single category in the list.
// The filters param is used to build the link with parent state via ForChild().
templ CategoryItem(category *eratov1.Category, filters FilterParams) {
	{{ slug := CategorySlug(category.GetPath()) }}
	<article
		id={ slug }
		data-kind={ KindCategory }
		if category.GetHidden() {
			data-hidden
		}
	>
		@Icon(KindCategory, 14)
		<a href={ templ.URL(filters.ForChild().BuildURL("/" + slug)) }>{ category.GetDisplayName() }</a>
		if category.GetDescription() != "" {
			<p>{ category.GetDescription() }</p>
		}
		<nav>
			@HideToggle(slug, category.GetHidden())
		</nav>
	</article>
}

// EntryList renders a list of entries with filter bar and pagination
templ EntryList(entries []*eratov1.Entry, props ListProps) {
	<section
		id={ IDListContainer }
		if props.Filters.ShowHidden {
			data-show-hidden
		}
	>
		<header>
			<h1>{ props.Title }</h1>
		</header>
		@FilterBar(props)
		<div role="list" aria-label={ props.Title }>
			if len(entries) == 0 {
				<p class="empty">No items match the current filters.</p>
			} else {
				for _, entry := range entries {
					@EntryItem(entry, props.Filters)
				}
			}
		</div>
		@Pagination(props)
	</section>
}

// ChapterList renders a list of chapters with pagination
templ ChapterList(chapters []*eratov1.Chapter, props ListProps) {
	<section id={ IDListContainer }>
		<header>
			<h1>{ props.Title }</h1>
		</header>
		<div role="list" aria-label={ props.Title }>
			if len(chapters) == 0 {
				<p class="empty">No chapters found.</p>
			} else {
				for _, chapter := range chapters {
					@ChapterItem(chapter, props.Filters)
				}
			}
		</div>
		@Pagination(props)
	</section>
}

// CategoryList renders a list of categories with filter bar and pagination
templ CategoryList(categories []*eratov1.Category, props ListProps) {
	<section
		id={ IDListContainer }
		if props.Filters.ShowHidden {
			data-show-hidden
		}
	>
		@FilterBar(props)
		<div role="list" aria-label="Categories">
			if len(categories) == 0 {
				<p class="empty">No categories found.</p>
			} else {
				for _, category := range categories {
					@CategoryItem(category, props.Filters)
				}
			}
		</div>
		@Pagination(props)
	</section>
}

// Pagination renders navigation controls for paginated lists.
// Only shows a Next button; users can use browser back for previous page.
// Uses a regular link (not HTMX) so the browser scrolls to top on navigation.
templ Pagination(props ListProps) {
	if props.NextPageToken != "" {
		<nav class={ ClassPagination }>
			<a href={ templ.URL(props.Filters.WithNextPage(props.NextPageToken).BuildURL(props.BaseURL)) }>
				Next
				@Icon("chevron-right", 16)
			</a>
		</nav>
	}
}

// kindToDataAttr converts an entry kind to a data attribute value
func kindToDataAttr(kind eratov1.Entry_Kind) string {
	if kind == eratov1.Entry_ANTHOLOGY {
		return KindAnthology
	}
	return KindStory
}
